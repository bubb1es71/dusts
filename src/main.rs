use bitcoin::consensus::{Decodable, ReadExt};
use bitcoin::hashes::Hash;
use bitcoin::io::Read;
use bitcoin::p2p::Magic;
use bitcoin::{Address, Amount, BlockHash, CompressedPublicKey, Network, ScriptBuf, Txid};
use clap::Parser;
use std::collections::{BTreeMap, HashSet};
use std::fmt::Debug;
use std::fs::{File, OpenOptions};
use std::io::Write;
use std::path::PathBuf;
use std::time::Instant;

// This tool borrows heavily from: https://github.com/bitcoin/bitcoin/blob/master/contrib/utxo-tools/utxo_to_sqlite.py
// The input UTXO set is generated by Bitcoin Core with the `dumptxoutset` RPC:
// `$ bitcoin-cli dumptxoutset data/utxos.dat latest`

const UTXO_DUMP_MAGIC: &[u8; 5] = b"utxo\xff";
const UTXO_DUMP_VERSION: u16 = 2;

// amount received to an address considered a potential victim for a dust attack
const VICTIM_SATS: u64 = 50_000_000;

// amount considered dust when sent the address of a potential victim for a dust attack
const DUST_SATS: u64 = 1000;

fn main() {
    let start = Instant::now();
    let args = CliArgs::parse();

    let mut in_file = OpenOptions::new()
        .read(true)
        .open(&args.in_file)
        .expect("unable to open input file");

    let mut out_file = File::create(&args.out_file).expect("unable to open output file");
    writeln!(out_file, "{}", Coin::csv_header()).expect("unable to write header to output file");

    let mut magic_buf = [0_u8; 5];
    in_file
        .read_exact(&mut magic_buf)
        .expect("unable to read magic");
    assert_eq!(&magic_buf, UTXO_DUMP_MAGIC, "invalid dump magic");

    let mut version_buf = [0_u8; 2];
    in_file
        .read_exact(&mut version_buf)
        .expect("unable to read dump version");
    let version = u16::from_le_bytes(version_buf);
    assert_eq!(version, UTXO_DUMP_VERSION, "invalid dump version");

    let mut network_magic = [0_u8; 4];
    in_file
        .read_exact(&mut network_magic)
        .expect("unable to read network magic");
    let network =
        Network::from_magic(Magic::from_bytes(network_magic)).expect("invalid network magic");
    let block_hash =
        BlockHash::consensus_decode(&mut in_file).expect("unable to decode block hash");
    let num_utxos = u64::consensus_decode(&mut in_file).expect("unable to decode number of utxos");

    let mut coins_per_txid = 0;
    let mut txid = Txid::all_zeros();
    let mut max_height = 0;

    // addresses that received an utxo for at least 50M sats
    let mut victim_addresses = HashSet::<Address>::new();

    // utxos that sent < 1000 sats to one of the above victim addresses
    let mut dust_coins = BTreeMap::<Address, Vec<Coin>>::new();

    // stats on the number and reuse of addresses for each script type
    let mut address_stats = AddressStats::default();

    for index in 1..num_utxos + 1 {
        // read key (COutPoint)
        if coins_per_txid == 0 {
            txid = Txid::consensus_decode(&mut in_file).expect("unable to decode prevout hash");
            coins_per_txid = read_compact_size(&mut in_file);
        }
        let mut coin = read_coin(&mut in_file, txid);
        // record if a previously seen victim coin received a dust utxo
        if coin.scriptpubkey.is_p2pkh()
            || coin.scriptpubkey.is_p2sh()
            || coin.scriptpubkey.is_p2wpkh()
            || coin.scriptpubkey.is_p2wsh()
            || coin.scriptpubkey.is_p2tr()
        {
            if coin.is_dust() {
                if victim_addresses.contains(&coin.address()) {
                    address_stats.increment_dust(&coin.scriptpubkey);
                    coin.counted = true;
                    writeln!(out_file, "{}", coin.to_csv_row())
                        .expect("unable to write dust coin to output file");
                    dust_coins
                        .entry(coin.address())
                        .or_default()
                        .push(coin.clone());
                } else {
                    dust_coins
                        .entry(coin.address())
                        .or_default()
                        .push(coin.clone());
                }
            }
            // record if a new victim coin was seen
            else if coin.value > Amount::from_sat(VICTIM_SATS) {
                address_stats.increment_victim(&coin.scriptpubkey);
                if let Some(dust_coins) = dust_coins.get_mut(&coin.address()) {
                    dust_coins
                        .iter_mut()
                        .filter(|coin| !coin.counted)
                        .for_each(|dust_coin| {
                            address_stats.increment_dust(&coin.scriptpubkey);
                            writeln!(out_file, "{}", dust_coin.to_csv_row())
                                .expect("unable to write dust coin to output file");
                            dust_coin.counted = true;
                        });
                }
                victim_addresses.insert(coin.address());
            }
        }

        if index % (1024 * 1024) == 0 {
            let duration = start.elapsed();
            println!(
                "{:10} coins loaded [{:3}%] {:.0?} remaining",
                index,
                ((index as f64 / num_utxos as f64) * 100_f64).round(),
                ((duration / index as u32) * (num_utxos - index) as u32)
            );
        }

        if coin.height > max_height {
            max_height = coin.height;
        }
        coins_per_txid = coins_per_txid.saturating_sub(1);
    }

    let duration = start.elapsed();
    println!(
        "\nProcessed {} utxos in {:?}, {} utxos/s.",
        num_utxos,
        duration,
        (num_utxos as f64 / duration.as_secs_f64()).round()
    );

    println!("network: {}", &network);
    println!("chain tip block hash: {}", &block_hash);
    println!("num utxos: {}", &num_utxos);

    println!("| script type | victim utxos | dust utxos | total | dust % of victims |");
    println!("| ----------- | ------------ | ---------- | ----- | ----------------- |");
    println!(
        "| P2PKH | {} | {} | {} | {:.2} |",
        address_stats.p2pkh_victim,
        address_stats.p2pkh_dust,
        address_stats.p2pkh_total(),
        address_stats.p2pkh_dust_percent()
    );
    println!(
        "| P2SH | {} | {} | {} | {:.2} |",
        address_stats.p2sh_victim,
        address_stats.p2sh_dust,
        address_stats.p2sh_total(),
        address_stats.p2sh_dust_percent()
    );
    println!(
        "| P2WPKH | {} | {} | {} | {:.2} |",
        address_stats.p2wpkh_victim,
        address_stats.p2wpkh_dust,
        address_stats.p2wpkh_total(),
        address_stats.p2wpkh_dust_percent()
    );
    println!(
        "| P2WSH | {} | {} | {} | {:.2} |",
        address_stats.p2wsh_victim,
        address_stats.p2wsh_dust,
        address_stats.p2wsh_total(),
        address_stats.p2wsh_dust_percent()
    );
    println!(
        "| P2TR | {} | {} | {} | {:.2} |",
        address_stats.p2tr_victim,
        address_stats.p2tr_dust,
        address_stats.p2tr_total(),
        address_stats.p2tr_dust_percent()
    );
}

fn read_coin(file: &mut File, txid: Txid) -> Coin {
    // read value (Coin)
    let vout = read_compact_size(file);
    let code = read_varint(file);
    let height = code >> 1;
    let is_coinbase = code & 1 == 1;
    let compressed_amount = read_varint(file);
    let amount = decompress_amount(compressed_amount);
    let value = Amount::from_sat(amount);
    let script = decompress_script(file);
    let scriptpubkey = ScriptBuf::from_bytes(script.clone());
    Coin::new(txid, is_coinbase, vout, value, height, scriptpubkey)
}

// txid, vout, value, height, scriptpubkey
#[derive(Clone, Hash, PartialEq, Eq)]
struct Coin {
    pub txid: Txid,
    pub is_coinbase: bool,
    pub vout: u64,
    pub value: Amount,
    pub height: u64,
    pub scriptpubkey: ScriptBuf,
    pub counted: bool,
}

impl Coin {
    pub fn new(
        txid: Txid,
        is_coinbase: bool,
        vout: u64,
        value: Amount,
        height: u64,
        scriptpubkey: ScriptBuf,
    ) -> Self {
        Coin {
            txid,
            is_coinbase,
            vout,
            value,
            height,
            scriptpubkey,
            counted: false,
        }
    }

    pub fn address(&self) -> Address {
        Address::from_script(&self.scriptpubkey, Network::Bitcoin).expect("invalid scriptpubkey")
    }

    pub fn script_type(&self) -> &'static str {
        if self.scriptpubkey.is_p2pkh() {
            "P2PKH"
        } else if self.scriptpubkey.is_p2sh() {
            "P2SH"
        } else if self.scriptpubkey.is_p2wpkh() {
            "P2WPKH"
        } else if self.scriptpubkey.is_p2wsh() {
            "P2WSH"
        } else if self.scriptpubkey.is_p2tr() {
            "P2TR"
        } else {
            "UNKNOWN"
        }
    }

    pub fn is_dust(&self) -> bool {
        // if self.scriptpubkey.is_p2pkh() {
        //     self.value == Amount::from_sat(546)
        // } else if self.scriptpubkey.is_p2sh() {
        //     self.value == Amount::from_sat(540)
        // } else if self.scriptpubkey.is_p2wpkh() {
        //     self.value == Amount::from_sat(294)
        // } else {
        //     self.value == Amount::from_sat(330)
        // }
        self.value < Amount::from_sat(DUST_SATS)
    }

    fn to_csv_row(&self) -> String {
        format!(
            "{},{},{},{},{},{},{}",
            self.txid,
            self.is_coinbase,
            self.vout,
            self.value.to_sat(),
            self.height,
            self.address(),
            self.script_type()
        )
    }

    fn csv_header() -> &'static str {
        "txid,is_coinbase,vout,value,height,address,type"
    }
}

impl From<(&[u8], bool, u64, u64, u64, &[u8])> for Coin {
    fn from(data: (&[u8], bool, u64, u64, u64, &[u8])) -> Self {
        let (txid, is_coinbase, vout, value, height, scriptpubkey) = data;
        let txid = Txid::from_slice(txid).expect("unable to decode txid");
        let value = Amount::from_sat(value);
        let scriptpubkey = ScriptBuf::from_bytes(scriptpubkey.to_vec());
        Coin::new(txid, is_coinbase, vout, value, height, scriptpubkey)
    }
}

impl Debug for Coin {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let address = self.address();
        let coinbase = if self.is_coinbase { "(CB)" } else { "" };
        write!(
            f,
            "[{}] {}{}:{} -> {}:{}",
            self.height, self.txid, coinbase, self.vout, address, self.value,
        )
    }
}

/// Equivalent of `ReadCompactSize()` (see serialization module).
fn read_compact_size(file: &mut File) -> u64 {
    let mut n = file.read_u8().expect("unable to read u8 compact size") as u64;
    if n == 253 {
        n = file.read_u16().expect("unable to read u16 compact size") as u64
    } else if n == 254 {
        n = file.read_u32().expect("unable to read u32 compact size") as u64
    } else if n == 255 {
        n = file.read_u64().expect("unable to read u64 compact size")
    }
    n
}

/// Equivalent of `ReadVarInt()` (see serialization module).
fn read_varint(file: &mut File) -> u64 {
    let mut n: u64 = 0;
    loop {
        let dat = file.read_u8().expect("unable to read varint") as u64;
        n = (n << 7) | (dat & 0x7f);
        if (dat & 0x80) > 0 { n += 1 } else { return n }
    }
}

/// Equivalent of `DecompressAmount()` (see compressor module).
fn decompress_amount(mut x: u64) -> u64 {
    // x = 0  OR  x = 1+10*(9*n + d - 1) + e  OR  x = 1+10*(n - 1) + 9
    if x == 0 {
        return 0;
    }
    x -= 1;
    // x = 10*(9*n + d - 1) + e
    let mut e = x % 10;
    x /= 10;
    let mut n;
    if e < 9 {
        // x = 9*n + d - 1
        let d = (x % 9) + 1;
        x /= 9;
        // x = n
        n = x * 10 + d;
    } else {
        n = x + 1;
    }
    while e > 0 {
        n *= 10;
        e -= 1;
    }
    n
}

/// Equivalent of `DecompressScript()` (see compressor module).
fn decompress_script(file: &mut File) -> Vec<u8> {
    // sizes 0-5 encode compressed script types
    let size = read_varint(file);

    // P2PKH
    if size == 0 {
        let mut read_buffer = [0_u8; 20];
        file.read_exact(&mut read_buffer)
            .expect("unable to read P2PKH script");
        let mut script = vec![0x76, 0xa9, 20];
        script.extend_from_slice(&read_buffer);
        script.extend_from_slice(&[0x88, 0xac]);
        script
    }
    // P2SH
    else if size == 1 {
        let mut read_buffer = [0_u8; 20];
        file.read_exact(&mut read_buffer)
            .expect("unable to read P2SH script");
        let mut script = vec![0xa9, 20];
        script.extend_from_slice(&read_buffer);
        script.extend_from_slice(&[0x87]);
        script
    }
    // P2PK (compressed)
    else if size == 2 || size == 3 {
        let mut read_buffer = [0_u8; 32];
        file.read_exact(&mut read_buffer)
            .expect("unable to read P2PK (compressed) script");
        let mut script = vec![33, size as u8];
        script.extend_from_slice(&read_buffer);
        script.extend_from_slice(&[0xac]);
        script
    }
    // P2PK (uncompressed)
    else if size == 4 || size == 5 {
        let mut read_buffer = [0_u8; 32];
        file.read_exact(&mut read_buffer)
            .expect("unable to read P2PK (uncompressed) script");
        let mut compressed_pubkey = vec![size as u8 - 2];
        compressed_pubkey.extend_from_slice(&read_buffer);
        let mut script = vec![65];
        let decompressed_pubkey = CompressedPublicKey::from_slice(&compressed_pubkey)
            .unwrap()
            .to_bytes();
        script.extend_from_slice(&decompressed_pubkey);
        script.extend_from_slice(&[0xac]);
        script
    }
    // others (bare multisig, segwit etc.)
    else {
        let size = size - 6;
        assert!(size <= 10000, "too long script with size {size}");
        let mut read_buffer = vec![0_u8; size as usize];
        file.read_exact(&mut read_buffer)
            .expect("unable to read script");
        read_buffer
    }
}

/// A tool that parses "bitcoin-cli dumptxoutset latest" output files to gather dust statistics and details
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
pub struct CliArgs {
    /// Filename of compact-serialized UTXO set file to load
    #[arg(env = "DUSTS_INFILE", value_parser = clap::value_parser!(PathBuf))]
    in_file: PathBuf,

    /// Filename for saving dust coin data
    #[arg(default_value = "dusts.csv", env = "DUSTS_DATADIR", value_parser = clap::value_parser!(PathBuf))]
    out_file: PathBuf,
}

#[derive(Clone, Debug, Default)]
struct AddressStats {
    pub p2pkh_victim: usize,
    pub p2pkh_dust: usize,
    pub p2sh_victim: usize,
    pub p2sh_dust: usize,
    pub p2wpkh_victim: usize,
    pub p2wpkh_dust: usize,
    pub p2wsh_victim: usize,
    pub p2wsh_dust: usize,
    pub p2tr_victim: usize,
    pub p2tr_dust: usize,
}

impl AddressStats {
    pub fn increment_victim(&mut self, scriptpubkey: &ScriptBuf) {
        // count script types
        if scriptpubkey.is_p2pkh() {
            self.p2pkh_victim += 1;
        } else if scriptpubkey.is_p2sh() {
            self.p2sh_victim += 1;
        } else if scriptpubkey.is_p2wpkh() {
            self.p2wpkh_victim += 1;
        } else if scriptpubkey.is_p2wsh() {
            self.p2wsh_victim += 1;
        } else if scriptpubkey.is_p2tr() {
            self.p2tr_victim += 1;
        }
    }

    pub fn increment_dust(&mut self, scriptpubkey: &ScriptBuf) {
        // count by script type
        if scriptpubkey.is_p2pkh() {
            self.p2pkh_dust += 1;
        } else if scriptpubkey.is_p2sh() {
            self.p2sh_dust += 1;
        } else if scriptpubkey.is_p2wpkh() {
            self.p2wpkh_dust += 1;
        } else if scriptpubkey.is_p2wsh() {
            self.p2wsh_dust += 1;
        } else if scriptpubkey.is_p2tr() {
            self.p2tr_dust += 1;
        }
    }

    pub fn p2pkh_total(&self) -> usize {
        self.p2pkh_dust + self.p2pkh_victim
    }

    pub fn p2sh_total(&self) -> usize {
        self.p2sh_dust + self.p2sh_victim
    }

    pub fn p2wpkh_total(&self) -> usize {
        self.p2wpkh_dust + self.p2wpkh_victim
    }

    pub fn p2wsh_total(&self) -> usize {
        self.p2wsh_dust + self.p2wsh_victim
    }

    pub fn p2tr_total(&self) -> usize {
        self.p2tr_dust + self.p2tr_victim
    }

    pub fn p2pkh_dust_percent(&self) -> f64 {
        (self.p2pkh_dust as f64 / self.p2pkh_victim as f64) * 100.0
    }

    pub fn p2sh_dust_percent(&self) -> f64 {
        (self.p2sh_dust as f64 / self.p2sh_victim as f64) * 100.0
    }

    pub fn p2wpkh_dust_percent(&self) -> f64 {
        (self.p2wpkh_dust as f64 / self.p2wpkh_victim as f64) * 100.0
    }

    pub fn p2wsh_dust_percent(&self) -> f64 {
        (self.p2wsh_dust as f64 / self.p2wsh_victim as f64) * 100.0
    }

    pub fn p2tr_dust_percent(&self) -> f64 {
        (self.p2tr_dust as f64 / self.p2tr_victim as f64) * 100.0
    }
}

#[cfg(test)]
mod test {
    use crate::decompress_amount;

    #[test]
    fn test_decompress_amount() {
        assert_eq!(decompress_amount(0), 0);
    }
}
